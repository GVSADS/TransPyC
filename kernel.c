 /*
                  ___         ___     
      ___        /  /\       /  /\    
     /  /\      /  /::\     /  /:/    
    /  /:/     /  /:/\:\   /  /:/     
   /  /:/     /  /:/~/:/  /  /:/  ___ 
  /  /::\    /__/:/ /:/  /__/:/  /  /\
 /__/:/\:\   \  \:\/:/   \  \:\ /  /:/
 \__\/  \:\   \  \::/     \  \:\  /:/ 
      \  \:\   \  \:\      \  \:\/:/  
       \__\/    \  \:\      \  \::/   
                 \__\/       \__\/    
Copyright GVSDS Team
Actor TermiNexus 
Generated by TransPyC
*/


#include "kernel2.h" // from kernel2 import *
#include <stdio.h>
#include <string.h>
#define F1 -1
#define F2 -2
#define F3 -3
#define F4 -4
#define F5 -5
#define F6 -6
#define F7 -7
#define F8 -8
#define F9 -9
#define F10 -10
#define F11 -11
#define F12 -12
#define ESC -350
#define BCK 0x08
#define TAB 0x09
#define LSH -158
#define LCT -187
#define LAL -141
#define FXU -111
#define FXD -112
#define FXL -113
#define FXR -114
#define XEN -120
#define RCT -121
#define XXG -122
#define RSH -123
#define RAL -124
#define HME -125
#define PGU -126
#define END -127
#define PGD -128
#define INS -129
#define DEL -130
#define WIN -131
#define RMN -132
int MOUSEX;
int MOUSEY;
int MOUSEBTN;
struct SHEET* sht_back;
struct SHEET* sht_mouse;
struct SHTCTL* shtctl;
unsigned int memtotal;
struct BOOTINFO* binfo = ((struct BOOTINFO *)ADR_BOOTINFO);
struct SHEET* sht_start;
unsigned char buf_start;
int sht_start_flan = 0;
char* RegistrationCode = "0x000001";
struct FILEINFO* finfo;
struct SHEET* sht = 0;
struct SHEET* key_win;
struct SHEET* sht2;
struct FIFO32 fifo;
struct FIFO32 keycmd;
int key_shift = 0;
int key_leds = 0;
int keycmd_wait = -1;
char* imewords;
struct MEMMAN* memman = ((struct MEMMAN *)MEMMAN_ADDR);
int* fat;
int i;
int pxdeep = 16;
int Input_method = 0;
int mousemode = 3;
static char keytable0[0x80] = {0, 0, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 0x08, 0, 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '[', ']', 0x0a, 0, 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ';', '\'', '`', 0, '\\', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', '/', 0, '*', 0, ' ', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '7', 0, '9', '-', '4', '5', '6', '+', '1', 0, '3', '0', '.', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x5c, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x5c, 0, 0};
static char keytable1[0x80] = {0, 0, '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', 0x08, 0, 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', 0x0a, 0, 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '"', '~', 0, '|', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '<', '>', '?', 0, '*', 0, ' ', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '7', '8', '9', '-', '4', '5', '6', '+', '1', '2', '3', '0', '.', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '_', 0, 0, 0, 0, 0, 0, 0, 0, 0, '|', 0, 0};
int cmdico[16][16] = {{7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7}, {15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 7, 7, 7, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 7, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0}, {0, 7, 7, 7, 0, 7, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7}};
void keywin_off(struct SHEET* key_win);
void keywin_on(struct SHEET* key_win);
void close_console(struct SHEET* sht);
void close_constask(struct TASK* task);
void SAIBMain(void) {
    int j;
    int x;
    int y;
    int mmx = -1;
    int mmy = -1;
    int mmx2 = 0;
    struct SHEET* cmd;
    struct TIMER* timer_systime;
    struct TIMER* start_d;
    extern char font[4096];
    char s[40];
    int fifobuf[128];
    int keycmd_buf[32];
    int mx;
    int my;
    int i;
    int new_mx = -1;
    int new_my = 0;
    int new_wx = 0x7fffffff;
    int new_wy = 0;
    struct MOUSE_DEC mdec;
    unsigned char* buf_back;
    unsigned char buf_mouse[256];
    key_shift = 0;
    key_leds = ((binfo->leds >> 4) & 7);
    keycmd_wait = -1;
    struct TASK* task_a;
    struct TASK* task;
    unsigned char* nihongo;
    init_gdtidt();
    init_pic();
    io_sti();
    fifo32_init(&fifo, 128, fifobuf, 0);
    *((int*)0x0fec) = ((int)&fifo);
    init_pit();
    init_keyboard(&fifo, 256);
    enable_mouse(&fifo, 512, &mdec);
    io_out8(PIC0_IMR, 0xf8);
    io_out8(PIC1_IMR, 0xef);
    fifo32_init(&keycmd, 32, keycmd_buf, 0);
    init_acpi();
    memtotal = memtest(0x00400000, 0xbfffffff);
    memman_init(memman);
    memman_free(memman, 0x00001000, 0x0009e000);
    memman_free(memman, 0x00400000, (memtotal - 0x00400000));
    init_color();
    shtctl = shtctl_init(memman, binfo->vram, binfo->scrnx, binfo->scrny);
    task_a = task_init(memman);
    fifo.task = task_a;
    task_run(task_a, 1, 2);
    *((int*)0x0fe4) = ((int)shtctl);
    task_a->langmode = 0;
    timer_systime = timer_alloc();
    timer_init(timer_systime, &fifo, 100);
    timer_settime(timer_systime, 100);
    sht_back = sheet_alloc(shtctl);
    buf_back = ((unsigned char *)memman_alloc_4k(memman, (binfo->scrnx * binfo->scrny)));
    sheet_setbuf(sht_back, buf_back, binfo->scrnx, binfo->scrny, -1);
    init_desktop(buf_back, binfo->scrnx, binfo->scrny);
    sht_start = sheet_alloc(shtctl);
    buf_start = ((unsigned char *)memman_alloc_4k(memman, (450 * 600)));
    sheet_setbuf(sht_start, buf_start, 450, 600, -1);
    init_start(sht_start);
    sheet_slide(sht_start, 0, (binfo->scrny - 630));
    key_win = open_console(shtctl, memtotal);
    cmd = key_win;
    sht_mouse = sheet_alloc(shtctl);
    sheet_setbuf(sht_mouse, buf_mouse, 16, 16, 99);
    init_mouse_cursor8(buf_mouse, 99);
    mx = ((binfo->scrnx - 16) / 2);
    my = (((binfo->scrny - 28) - 16) / 2);
    sheet_slide(sht_back, 0, 0);
    sheet_slide(key_win, 32, 4);
    sheet_slide(sht_mouse, MOUSEX, MOUSEY);
    sheet_updown(sht_back, 0);
    sheet_updown(key_win, 2);
    sheet_updown(sht_mouse, 3);
    keywin_on(key_win);
    fifo32_put(&keycmd, KEYCMD_LED);
    fifo32_put(&keycmd, key_leds);
    nihongo = ((unsigned char *)memman_alloc_4k(memman, (0x5d5d * 32)));
    fat = ((int *)memman_alloc_4k(memman, (4 * 2880)));
    file_readfat(fat, ((unsigned char *)(ADR_DISKIMG + 0x000200)));
    finfo = file_search("HZK16.fnt", ((struct FILEINFO *)(ADR_DISKIMG + 0x002600)), 224);
    if ((finfo != 0)) {
        file_loadfile(finfo->clustno, finfo->size, nihongo, fat, ((char *)(ADR_DISKIMG + 0x003e00)));
    }
    else {
        for (int i = 0; i < (16 * 256); i += 1) {
            nihongo[i] = font[i];
        }
        for (int i = (16 * 256); i < ((16 * 256) + ((32 * 94) * 47)); i += 1) {
            nihongo[i] = 0xff;
        }
    }
    *((int*)0x0fe8) = ((int)nihongo);
    memman_free_4k(memman, ((int)fat), (4 * 2880));
    while (1) {
        if (((fifo32_status(&keycmd) > 0)) && ((keycmd_wait < 0))) {
            keycmd_wait = fifo32_get(&keycmd);
            wait_KBC_sendready();
            io_out8(PORT_KEYDAT, keycmd_wait);
        }
        io_cli();
        if ((fifo32_status(&fifo) == 0)) {
            if ((new_mx >= 0)) {
                io_sti();
                sheet_slide(sht_mouse, new_mx, new_my);
                new_mx = -1;
            }
            else if ((new_wx != 0x7fffffff)) {
                io_sti();
                sheet_slide(sht, new_wx, new_wy);
                new_wx = 0x7fffffff;
            }
            else {
                task_sleep(task_a);
                io_sti();
            }
        }
        else {
            i = fifo32_get(&fifo);
            j = fifo.buf[(((fifo.q - 2) + fifo.size) % fifo.size)];
            io_sti();
            if (((key_win != 0)) && ((key_win->flags == 0))) {
                if ((shtctl->top == 1)) {
                    key_win = 0;
                }
                else {
                    key_win = shtctl->sheets[(shtctl->top - 1)];
                    keywin_on(key_win);
                }
            }
            if (((256 <= i)) && ((i <= 511))) {
                if ((i < (0x80 + 256))) {
                    if ((key_shift == 0)) {
                        s[0] = keytable0[(i - 256)];
                    }
                    else {
                        s[0] = keytable1[(i - 256)];
                    }
                }
                else {
                    s[0] = 0;
                }
                if ((('A' <= s[0])) && ((s[0] <= 'Z'))) {
                    if (((((key_leds & 4) == 0)) && ((key_shift == 0))) || ((((key_leds & 4) != 0)) && ((key_shift != 0)))) {
                        s[0] += 0x20;
                    }
                }
                if (((s[0] != 0)) && ((key_win != 0))) {
                    fifo32_put(&key_win->task->fifo, (s[0] + 256));
                }
                if (((i == (256 + 0x0f))) && ((key_win != 0))) {
                    keywin_off(key_win);
                    j = (key_win->height - 1);
                    if ((j == 0)) {
                        j = (shtctl->top - 1);
                    }
                    key_win = shtctl->sheets[j];
                    keywin_on(key_win);
                }
                if ((i == (256 + 0x63))) {
                    key_shift |= 2;
                }
                if ((i == (256 + 0x2a))) {
                    key_shift |= 1;
                }
                if ((i == (256 + 0x36))) {
                    key_shift |= 2;
                }
                if ((i == (256 + 0xaa))) {
                    key_shift &= ~1;
                }
                if ((i == (256 + 0xb6))) {
                    key_shift &= ~2;
                }
                if ((i == (256 + 0x3a))) {
                    key_leds ^= 4;
                    fifo32_put(&keycmd, KEYCMD_LED);
                    fifo32_put(&keycmd, key_leds);
                }
                if ((i == (256 + 0x45))) {
                    key_leds ^= 2;
                    fifo32_put(&keycmd, KEYCMD_LED);
                    fifo32_put(&keycmd, key_leds);
                }
                if ((i == (256 + 0x46))) {
                    key_leds ^= 1;
                    fifo32_put(&keycmd, KEYCMD_LED);
                    fifo32_put(&keycmd, key_leds);
                }
                if (((i == (256 + 0x3b))) && ((key_shift != 0)) && ((key_win != 0))) {
                    task = key_win->task;
                    if (((task != 0)) && ((task->tss.ss0 != 0))) {
                        cons_putstr0(task->cons, "");
                        io_cli();
                        task->tss->eax = ((int)&task->tss.esp0);
                        task->tss->eip = ((int)asm_end_app);
                        io_sti();
                        task_run(task, -1, 0);
                    }
                }
                if (((i == (256 + 0x3c))) && ((key_shift != 0))) {
                    if ((key_win != 0)) {
                        keywin_off(key_win);
                    }
                    key_win = open_console(shtctl, memtotal);
                    sheet_slide(key_win, 32, 4);
                    sheet_updown(key_win, shtctl->top);
                    keywin_on(key_win);
                }
                if ((i == (256 + 0x57))) {
                    sheet_updown(shtctl->sheets[1], (shtctl->top - 1));
                }
                if ((i == (256 + 0xfa))) {
                    keycmd_wait = -1;
                }
                if ((i == (256 + 0xfe))) {
                    wait_KBC_sendready();
                    io_out8(PORT_KEYDAT, keycmd_wait);
                }
            }
            else if (((512 <= i)) && ((i <= 767))) {
                if ((mouse_decode(&mdec, (i - 512)) != 0)) {
                    mx += mdec.x;
                    my += mdec.y;
                    if ((mx < 0)) {
                        mx = 0;
                    }
                    if ((my < 0)) {
                        my = 0;
                    }
                    if ((mx > (binfo->scrnx - 1))) {
                        mx = (binfo->scrnx - 1);
                    }
                    if ((my > (binfo->scrny - 1))) {
                        my = (binfo->scrny - 1);
                    }
                    new_mx = mx;
                    new_my = my;
                    MOUSEX = mx;
                    MOUSEY = my;
                    MOUSEBTN = mdec.btn;
                    win_zonclick(MOUSEBTN, MOUSEX, MOUSEY, 0, (binfo->scrny - 30), 30, binfo->scrny, sht_start_flan, sht);
                    sht_start_flan = win_szonclick(MOUSEBTN, MOUSEX, MOUSEY, 0, (binfo->scrny - 30), 30, binfo->scrny, sht_start_flan, sht);
                    if (((sht_start_flan == 1)) && ((binddmousebox(MOUSEX, MOUSEY, MOUSEBTN, 0, 0, binfo->scrnx, (binfo->scrny - 630), 1)) || (binddmousebox(MOUSEX, MOUSEY, MOUSEBTN, 400, (binfo->scrny - 630), binfo->scrnx, binfo->scrny, 1)) || (binddmousebox(MOUSEX, MOUSEY, MOUSEBTN, 30, (binfo->scrny - 30), 400, binfo->scrny, 1)) || (binddmousebox(MOUSEX, MOUSEY, MOUSEBTN, 0, 0, binfo->scrnx, (binfo->scrny - 630), 2)) || (binddmousebox(MOUSEX, MOUSEY, MOUSEBTN, 400, (binfo->scrny - 630), binfo->scrnx, binfo->scrny, 2)) || (binddmousebox(MOUSEX, MOUSEY, MOUSEBTN, 30, (binfo->scrny - 30), 400, binfo->scrny, 2)))) {
                        sheet_updown(sht_start, -1);
                        sht_start_flan = 0;
                    }
                    if (((mdec.btn & 0x01) != 0)) {
                        if ((mmx < 0)) {
                            for (int j = (shtctl->top - 1); j > 0; j += -1) {
                                sht = shtctl->sheets[j];
                                x = (mx - sht->vx0);
                                y = (my - sht->vy0);
                                if (((0 <= x)) && ((x < sht->bxsize)) && ((0 <= y)) && ((y < sht->bysize))) {
                                    sheet_updown(sht, (shtctl->top - 1));
                                    if ((sht != key_win)) {
                                        keywin_off(key_win);
                                        key_win = sht;
                                        keywin_on(key_win);
                                    }
                                    if (((3 <= x)) && ((x < (sht->bxsize - 3))) && ((3 <= y)) && ((y < 21))) {
                                        mmx = mx;
                                        mmy = my;
                                        mmx2 = sht->vx0;
                                        new_wy = sht->vy0;
                                    }
                                    if ((((sht->bxsize - 21) <= x)) && ((x < (sht->bxsize - 5))) && ((5 <= y)) && ((y < 19))) {
                                        if (((sht->flags & 0x10) != 0)) {
                                            task = sht->task;
                                            cons_putstr0(task->cons, "");
                                            io_cli();
                                            task->tss->eax = ((int)&task->tss.esp0);
                                            task->tss->eip = ((int)asm_end_app);
                                            io_sti();
                                            task_run(task, -1, 0);
                                        }
                                        else if ((sht->flags == 0x25)) {
                                        }
                                        else {
                                            task = sht->task;
                                            sheet_updown(sht, -1);
                                            keywin_off(key_win);
                                            key_win = shtctl->sheets[(shtctl->top - 1)];
                                            keywin_on(key_win);
                                            io_cli();
                                            fifo32_put(&task->fifo, 4);
                                            io_sti();
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                        else {
                            x = (mx - mmx);
                            y = (my - mmy);
                            new_wx = (((mmx2 + x) + 2) & ~3);
                            new_wy = (new_wy + y);
                            mmy = my;
                        }
                    }
                    else {
                        mmx = -1;
                        if ((new_wx != 0x7fffffff)) {
                            sheet_slide(sht, new_wx, new_wy);
                            new_wx = 0x7fffffff;
                        }
                    }
                }
            }
            else if (((768 <= i)) && ((i <= 1023))) {
                close_console((shtctl->sheets0 + (i - 768)));
            }
            else if (((1024 <= i)) && ((i <= 2023))) {
                close_constask((taskctl.tasks0 + (i - 1024)));
            }
            else if (((2024 <= i)) && ((i <= 2279))) {
                sht2 = (shtctl->sheets0 + (i - 2024));
                memman_free_4k(memman, ((int)sht2->buf), (256 * 165));
                sheet_free(sht2);
            }
            else if ((i == 100)) {
                sprintf(s, "%d/%d/%d", get_year(), get_mon_hex(), get_day_of_month());
                putfonts8_asc_sht(sht_back, (binfo->scrnx - 170), (binfo->scrny - 20), COL8_FFFFFF, COL8_RWL, s, 15);
                sprintf(s, "%d:%d:%d", get_hour_hex(), get_min_hex(), get_sec_hex());
                putfonts8_asc_sht(sht_back, (binfo->scrnx - 70), (binfo->scrny - 20), COL8_FFFFFF, COL8_RWL, s, 8);
                sheet_refresh(sht_back, (binfo->scrnx - 200), (binfo->scrny - 20), ((binfo->scrnx - 70) + (5 * 8)), ((binfo->scrny - 50) + 16));
                timer_settime(timer_systime, 100);
            }
        }
    }
}
void keywin_off(struct SHEET* key_win) {
    change_wtitle8(key_win, 0);
    if (((key_win->flags & 0x20) != 0)) {
        fifo32_put(&key_win->task->fifo, 3);
    }
    return;
}
void keywin_on(struct SHEET* key_win) {
    change_wtitle8(key_win, 1);
    if (((key_win->flags & 0x20) != 0)) {
        fifo32_put(&key_win->task->fifo, 2);
        fifo32_put(&key_win->task2.fifo, 2);
    }
    return;
}
struct TASK* open_constask(struct SHEET* sht, unsigned int memtotal) {
    struct MEMMAN* memman = ((struct MEMMAN *)MEMMAN_ADDR);
    struct TASK* task = task_alloc();
    int* cons_fifo = ((int *)memman_alloc_4k(memman, (128 * 4)));
    task->cons_stack = memman_alloc_4k(memman, (64 * 1024));
    task->tss->esp = ((task->cons_stack + (64 * 1024)) - 12);
    task->tss->eip = ((int)&console_task);
    task->tss->es = (1 * 8);
    task->tss->cs = (2 * 8);
    task->tss->ss = (1 * 8);
    task->tss->ds = (1 * 8);
    task->tss->fs = (1 * 8);
    task->tss->gs = (1 * 8);
    *((int*)(task->tss.esp + 4)) = ((int)sht);
    *((int*)(task->tss.esp + 8)) = memtotal;
    task_run(task, 2, 2);
    fifo32_init(&task->fifo, 128, cons_fifo, task);
    return task;
}
struct SHEET* open_console(struct SHTCTL* shtctl, unsigned int memtotal) {
    int i = 0;
    int j = 0;
    struct MEMMAN* memman = ((struct MEMMAN *)MEMMAN_ADDR);
    struct SHEET* sht = sheet_alloc(shtctl);
    unsigned char* buf = ((unsigned char *)memman_alloc_4k(memman, (525 * 479)));
    sheet_setbuf(sht, buf, 525, 479, 255);
    make_window8(buf, 525, 479, "Cmd.exw(System Internal storage)", 0);
    make_textbox8(sht, 3, 24, 519, 452, COL8_000000);
    for (int i = 0; i < 16; i += 1) {
        for (int j = 0; j < 16; j += 1) {
            buf[((((i + 4) * 525) + j) + 6)] = cmdico[i][j];
        }
    }
    sht->task = open_constask(sht, memtotal);
    sht->flags |= 0x20;
    return sht;
}
void close_constask(struct TASK* task) {
    struct MEMMAN* memman = ((struct MEMMAN *)MEMMAN_ADDR);
    task_sleep(task);
    memman_free_4k(memman, task->cons_stack, (64 * 1024));
    memman_free_4k(memman, ((int)task->fifo.buf), (525 * 4));
    task->flags = 0;
    return;
}
void close_console(struct SHEET* sht) {
    struct MEMMAN* memman = ((struct MEMMAN *)MEMMAN_ADDR);
    struct TASK* task = sht->task;
    memman_free_4k(memman, ((int)sht->buf), (770 * 655));
    sheet_free(sht);
    close_constask(task);
    return;
}
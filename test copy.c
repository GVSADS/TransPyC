 /*
                  ___         ___     
      ___        /  /\       /  /\    
     /  /\      /  /::\     /  /:/    
    /  /:/     /  /:/\:\   /  /:/     
   /  /:/     /  /:/~/:/  /  /:/  ___ 
  /  /::\    /__/:/ /:/  /__/:/  /  /\
 /__/:/\:\   \  \:\/:/   \  \:\ /  /:/
 \__\/  \:\   \  \::/     \  \:\  /:/ 
      \  \:\   \  \:\      \  \:\/:/  
       \__\/    \  \:\      \  \::/   
                 \__\/       \__\/    
Copyright© GVSDS Team
Actor TermiNexus

*/
// Generated by TransPyC



#include <stdio.h>
#include "kernel2.h" // from kernel2 import *
#define F1 -1
int MOUSEX;
static char keytable0[128];
unsigned char* buf_start;
int global_var = 100;
static int static_var = 200;
struct a {
    int k1;
    struct TASK* task;
    int led;
};
struct DLL_STRPICENV {
    int work[((64 * 1024) / 4)];
    struct FREEINFO *free[MEMMAN_FREES];
    struct SHEET *sheets[MAX_SHEETS];
    struct SHEET *sheets[MAX_SHEETS];
    struct SHEET sheets0[MAX_SHEETS];
};
extern struct TASKCTL* taskctl;
extern struct TIMER* task_timer;
extern int languages[MAX_LANGUAGE_NUMBER];
struct SHEET* sht_mouse;
struct SHTCTL* shtctl;
static char keytable0[128] = {0, 0, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 8, 0, 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '[', ']', 10, 0, 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ';', '\'', '`', 0, '\\', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', '/', 0, '*', 0, ' ', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '7', 0, '9', '-', '4', '5', '6', '+', '1', 0, '3', '0', '.', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92, 0, 0};
static char keytable1[128] = {0, 0, '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', 8, 0, 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', 10, 0, 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '"', '~', 0, '|', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '<', '>', '?', 0, '*', 0, ' ', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '7', '8', '9', '-', '4', '5', '6', '+', '1', '2', '3', '0', '.', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '_', 0, 0, 0, 0, 0, 0, 0, 0, 0, '|', 0, 0};
struct FIFO32 {
};
struct FIFO32 f;
struct BOOTINFO* binfo = ((struct BOOTINFO *)ADR_BOOTINFO);
struct FILEINFO* finfo;
void keywin_off(struct SHEET* key_win);
void keywin_off2(struct SHEET* key_win);
void io_hlt(void);
void test_ptr_operations(void) {
    *((void *)4096) = 42;
    *((int*)4096) = 42;
    int value = ((void *)4096);
    value = ((int*)4096);
    struct value* var;
    struct value* var2;
}
void test_type_casting(void) {
    int x = 42;
    int y = ((int)x);
    char z = ((char)x);
    int p = ((unsigned char *)x);
    int q = ((int)x);
    int r = ((char)x);
    if (x) {
        x = ((int)x);
        if (x) {
            x = ((int)x);
        }
    }
    if (x) {
        x = ((int)x);
    }
}
long int test_bubble_sort(void) {
    long int arr[7] = {64, 34, 25, 12, 22, 11, 90};
    int n = (sizeof(arr) / sizeof(arr[0]));
    for (int i = 0; i < n; i += 1) {
        for (int j = 0; j < ((n - i) - 1); j += 1) {
            if ((arr[j] > arr[(j + 1)])) {
                int temp;
                temp = arr[j];
                arr[j] = arr[(j + 1)];
                arr[(j + 1)] = temp;
            }
        }
    }
    printf("排序后的数组:");
    printf("
");
    for (int i = 0; i < n; i += 1) {
        printf("%d
", arr[i]);
    }
    return arr;
}
void a____init__(struct a* self, int led) {
    self->led = led;
}
int a__add(struct a* self, int x) {
    self->led += x;
    return self->led;
}
void a__test_bubble_sort(struct a* self) {
    long int arr[7] = {64, 34, 25, 12, 22, 11, 90};
    int n = (sizeof(arr) / sizeof(arr[0]));
    for (int i = 0; i < n; i += 1) {
        for (int j = 0; j < ((n - i) - 1); j += 1) {
            if ((arr[j] > arr[(j + 1)])) {
                int temp;
                temp = arr[j];
                arr[j] = arr[(j + 1)];
                arr[(j + 1)] = temp;
            }
        }
    }
    printf("排序后的数组:");
    printf("
");
    for (int i = 0; i < n; i += 1) {
        printf("%d
", arr[i]);
    }
}
void io_out8(uint8_t port, uint8_t value) {
    asm volatile ("out %0, %1" : : "a"(value), "d"(port));
}
struct TASK* open_constask(struct SHEET* sht, unsigned int memtotal);
struct TASK open_constask2(struct SHEET* sht, unsigned int memtotal);
int info_JPEG(struct DLL_STRPICENV* env, int* info, int size, uint8_t* fp);
void memman_free_4k(struct MEMMAN* man, unsigned int addr, unsigned int size);
void sheet_setbuf(struct SHEET* sht, unsigned char* buf, int xsize, int ysize, int col_inv);
int main(void) {
    finfo = file_search("HZK16.fnt", ((struct FILEINFO *)(ADR_DISKIMG + 9728)), 224);
    init_start(sht_start);
    file_loadfile(((char *)(ADR_DISKIMG + 15872)));
    file_loadfile(((char *)(ADR_DISKIMG + 15872)));
    buf_start = ((unsigned char *)memman_alloc_4k(memman, (450 * 600)));
    shtctl = shtctl_init(memman, binfo->vram, binfo->scrnx, binfo->scrny);
    static char keytable0[128];
    static char keytable1[128];
    extern char font1[4096];
    unsigned char* buf_back;
    unsigned char* buf_mouse[256][256];
    int memtotal = memtest(4194304, 3221225471);
    struct FIFO32 fifo;
    fifo.task = task_a;
    int key_leds = ((binfo->leds >> 4) & 7);
    long int K = test_bubble_sort();
    struct a s;
    a____init__(&s, 1);
    struct a* p;
    p = &s;
    a__test_bubble_sort(&s, s.k1, p->k1);
    *((int*)4076) = ((int)&fifo);
    io_out8(PIC1_IMR, 4194304);
    p->flags |= 32;
    int key_win = shtctl->sheets[(shtctl->top - 1)];
    key_shift &= ~1;
    return 0;
}
# 内联汇编与宏

## 内联汇编

### 单行汇编

```python
import c

def init_fpu():
    c.Asm("mov eax, cr0")
```

编译后：

```c
void init_fpu(void) {
    __asm__ volatile ("mov eax, cr0");
}
```

### 多行汇编

```python
import c

def init_fpu():
    c.Asm(""".intel_syntax noprefix
mov eax, cr0
and eax, 0x9ffffff
mov cr0, eax
fninit""")
```

编译后：

```c
void init_fpu(void) {
    __asm__ volatile (
        ".intel_syntax noprefix\n\t"
        "mov eax, cr0\n\t"
        "and eax, 0x9ffffff\n\t"
        "mov cr0, eax\n\t"
        "fninit"
    );
}
```

### 带注释的汇编

```python
import c

def init_fpu():
    c.Asm("""
# 1. 读取 CR0 寄存器到 EAX
mov eax, cr0
# 2. 清除 TS 和 MP 位
and eax, 0x9ffffff
# 3. 写回 CR0
mov cr0, eax
# 4. 重置 FPU
fninit
""")
```

### 汇编中的变量

```python
import t, c

def set_cr0(val: t.CInt) -> t.CVoid:
    c.Asm("mov eax, %0" % val)
    c.Asm("mov cr0, eax")
```

## 宏定义

### 常量宏

```python
# 全局常量
MEMMAN_ADDR = 0x003c0000
MAX_SHEETS = 256
```

编译后：

```c
#define MEMMAN_ADDR 0x003c0000
#define MAX_SHEETS 256
```

### 带类型的常量

```python
import t

# 带类型的常量
BUFFER_SIZE: t.CConst | t.CInt = 1024
```

编译后：

```c
const int BUFFER_SIZE = 1024;
```

### 函数式宏

TransPyC 不支持函数式宏，建议使用内联函数代替：

```python
import t

def max(a: t.CInt, b: t.CInt) -> t.CInt:
    if a > b:
        return a
    return b
```

编译后：

```c
int max(int a, int b) {
    if ((a > b)) {
        return a;
    }
    return b;
}
```

## 条件编译

### #ifdef / #ifndef

```python
import c

c.Ifdef("DEBUG")
# 调试代码
c.Endif()

c.Ifndef("RELEASE")
# 非发布版本代码
c.Endif()
```

编译后：

```c
#ifdef DEBUG
#endif

#ifndef RELEASE
#endif
```

### #if

```python
import c

c.If("defined(DEBUG) && DEBUG > 0")
# 条件代码
c.Endif()
```

编译后：

```c
#if defined(DEBUG) && DEBUG > 0
#endif
```

### #else 和 #elif

```python
import c

c.Ifdef("DEBUG")
# 调试代码
c.Else()
# 发布代码
c.Endif()
```

编译后：

```c
#ifdef DEBUG
#else
#endif
```

## 头文件包含

### 系统头文件

```python
from UNCADK.stdlib import *  #include "../../.UNCADK/stdlib.h"
```

编译后：

```c
#include "../../.UNCADK/stdlib.h"
```

### 相对路径头文件

```python
from ..core.kernel import *   #include "../core/kernel.h"
from .utils import *          #include "utils.h"
```

编译后：

```c
#include "../core/kernel.h"
#include "utils.h"
```

### 标准库头文件

```python
import c

def main() -> t.CInt:
    c.Include("stdio.h")
    c.Include("stdlib.h")
    return 0
```

编译后：

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    return 0;
}
```

## 特殊标记

### 行标记

```python
import c

def main() -> t.CInt:
    c.LineMark(10, "source.py")
    x: t.CInt = 0
    return 0
```

编译后：

```c
#line 10 "source.py"
int main(void) {
    int x = 0;
    return 0;
}
```

### 编译器指令

```python
import c

def main() -> t.CInt:
    c.Pragma("pack(push, 1)")
    # 结构体定义
    c.Pragma("pack(pop)")
    return 0
```

编译后：

```c
#pragma pack(push, 1)
#pragma pack(pop)

int main(void) {
    return 0;
}
```

## 属性标记

### 函数属性

```python
import t, c

c.Attribute("noreturn")
def exit(code: t.CInt) -> t.CVoid:
    pass
```

编译后：

```c
__attribute__((noreturn))
void exit(int code) {
}
```

### 变量属性

```python
import t, c

def main() -> t.CInt:
    c.Attribute("aligned(16)")
    buffer: t.CChar[1024]
    return 0
```

编译后：

```c
int main(void) {
    __attribute__((aligned(16)))
    char buffer[1024];
    return 0;
}
```

## 汇编标签

### 定义标签

```python
import t, c

def loop() -> t.CVoid:
    c.Label("start")
    # 循环体
    c.Goto("start")
```

编译后：

```c
void loop(void) {
start:
    goto start;
}
```

### 在汇编中使用标签

```python
import c

def wait():
    c.Asm("""
    jmp 1f
1:
    pause
    jmp 1b
""")
```

## 内存屏障

```python
import c

def memory_barrier():
    c.Asm("mfence")
```

编译后：

```c
void memory_barrier(void) {
    __asm__ volatile ("mfence");
}
```

## 读写特殊寄存器

```python
import t, c

def read_cr0() -> t.CInt:
    c.Asm("mov eax, cr0")
    return 0  # 实际值在 eax 中

def write_cr0(val: t.CInt) -> t.CVoid:
    c.Asm("mov cr0, eax")
```

## 中断控制

```python
import c

def disable_interrupts():
    c.Asm("cli")

def enable_interrupts():
    c.Asm("sti")
```

编译后：

```c
void disable_interrupts(void) {
    __asm__ volatile ("cli");
}

void enable_interrupts(void) {
    __asm__ volatile ("sti");
}
```

## I/O 端口操作

```python
import t, c

def inb(port: t.CInt) -> t.CChar:
    c.Asm("in al, dx")
    return 0

def outb(port: t.CInt, val: t.CChar) -> t.CVoid:
    c.Asm("out dx, al")
```

## CPU 特性检测

```python
import t, c

def cpuid(leaf: t.CInt) -> t.CVoid:
    c.Asm("cpuid")
```

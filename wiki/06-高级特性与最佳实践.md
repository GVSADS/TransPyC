# 高级特性与最佳实践

## 内存管理

### 动态内存分配

```python
import t, c

def allocate_buffer(size: t.CInt) -> t.CPtr | t.CChar:
    buf: t.CPtr | t.CChar = c.malloc(size)
    return buf

def free_buffer(buf: t.CPtr | t.CChar) -> t.CVoid:
    c.free(buf)
```

编译后：

```c
char* allocate_buffer(int size) {
    char* buf = malloc(size);
    return buf;
}

void free_buffer(char* buf) {
    free(buf);
}
```

### 内存拷贝

```python
import t, c

def copy_memory(dst: t.CPtr | t.CVoid, src: t.CPtr | t.CVoid, size: t.CInt) -> t.CVoid:
    c.memcpy(dst, src, size)
```

编译后：

```c
void copy_memory(void* dst, void* src, int size) {
    memcpy(dst, src, size);
}
```

### 内存清零

```python
import t, c

def zero_memory(ptr: t.CPtr | t.CVoid, size: t.CInt) -> t.CVoid:
    c.memset(ptr, 0, size)
```

编译后：

```c
void zero_memory(void* ptr, int size) {
    memset(ptr, 0, size);
}
```

## 字符串操作

### 字符串声明

```python
import t

def main() -> t.CInt:
    # 字符数组
    str1: t.CChar[20] = "Hello, World!"
    
    # 字符指针
    str2: t.CChar | t.CPtr = "Hello"
    
    return 0
```

编译后：

```c
int main(void) {
    char str1[20] = "Hello, World!";
    char* str2 = "Hello";
    
    return 0;
}
```

### 字符串函数

```python
import t, c

def string_operations() -> t.CVoid:
    src: t.CChar | t.CPtr = "Hello"
    dst: t.CChar[20]
    
    # 字符串拷贝
    c.strcpy(dst, src)
    
    # 字符串连接
    c.strcat(dst, " World")
    
    # 字符串长度
    len: t.CInt = c.strlen(src)
```

编译后：

```c
void string_operations(void) {
    char* src = "Hello";
    char dst[20];
    
    strcpy(dst, src);
    strcat(dst, " World");
    int len = strlen(src);
}
```

## 位域操作

### 位域结构体

```python
import t

class Flags(t.CStruct):
    flag1: t.CInt  # 1 bit
    flag2: t.CInt  # 1 bit
    flag3: t.CInt  # 1 bit
    reserved: t.CInt  # 29 bits

def main() -> t.CInt:
    f: Flags
    f.flag1 = 1
    f.flag2 = 0
    
    return 0
```

编译后：

```c
struct Flags {
    int flag1;
    int flag2;
    int flag3;
    int reserved;
};

int main(void) {
    struct Flags f;
    f.flag1 = 1;
    f.flag2 = 0;
    
    return 0;
}
```

### 位操作宏

```python
import t

def set_bit(val: t.CInt | t.CPtr, bit: t.CInt) -> t.CVoid:
    val[0] = val[0] | (1 << bit)

def clear_bit(val: t.CInt | t.CPtr, bit: t.CInt) -> t.CVoid:
    val[0] = val[0] & ~(1 << bit)

def test_bit(val: t.CInt, bit: t.CInt) -> t.CInt:
    return (val >> bit) & 1
```

编译后：

```c
void set_bit(int* val, int bit) {
    val[0] = (val[0] | (1 << bit));
}

void clear_bit(int* val, int bit) {
    val[0] = (val[0] & (~(1 << bit)));
}

int test_bit(int val, int bit) {
    return ((val >> bit) & 1);
}
```

## 链表实现

### 链表节点

```python
import t

class ListNode(t.CStruct):
    data: t.CInt
    next: t.CStruct(name="ListNode") | t.CPtr
```

编译后：

```c
struct ListNode {
    int data;
    struct ListNode* next;
};
```

### 链表操作

```python
import t, c

class ListNode(t.CStruct):
    data: t.CInt
    next: t.CStruct(name="ListNode") | t.CPtr

def create_node(data: t.CInt) -> t.CStruct(name="ListNode") | t.CPtr:
    node: t.CStruct(name="ListNode") | t.CPtr = c.malloc(t.sizeof(ListNode))
    node.data = data
    node.next = 0
    return node

def append_node(head: t.CPtr | t.CStruct(name="ListNode"), data: t.CInt) -> t.CVoid:
    new_node: t.CStruct(name="ListNode") | t.CPtr = create_node(data)
    
    if head == 0:
        head = new_node
        return
    
    current: t.CStruct(name="ListNode") | t.CPtr = head
    while current.next != 0:
        current = current.next
    
    current.next = new_node
```

## 错误处理

### 错误码定义

```python
import t

# 错误码
SUCCESS = 0
ERROR_INVALID_PARAM = -1
ERROR_OUT_OF_MEMORY = -2
ERROR_NOT_FOUND = -3

def process_data(data: t.CPtr | t.CInt) -> t.CInt:
    if data == 0:
        return ERROR_INVALID_PARAM
    
    # 处理数据
    
    return SUCCESS
```

编译后：

```c
#define SUCCESS 0
#define ERROR_INVALID_PARAM -1
#define ERROR_OUT_OF_MEMORY -2
#define ERROR_NOT_FOUND -3

int process_data(int* data) {
    if ((data == 0)) {
        return -1;
    }
    
    return 0;
}
```

## 调试技巧

### 调试输出

```python
import t, c

def debug_print(msg: t.CPtr | t.CChar) -> t.CVoid:
    c.printf("[DEBUG] %s\n", msg)

def debug_value(name: t.CPtr | t.CChar, val: t.CInt) -> t.CVoid:
    c.printf("[DEBUG] %s = %d\n", name, val)
```

### 断言

```python
import t, c

def assert_condition(cond: t.CInt, msg: t.CPtr | t.CChar) -> t.CVoid:
    if not cond:
        c.printf("Assertion failed: %s\n", msg)
        c.exit(1)
```

## 性能优化

### 内联函数

```python
import t

def min(a: t.CInt, b: t.CInt) -> t.CInt:
    if a < b:
        return a
    return b
```

### 寄存器变量

```python
import t

def fast_loop() -> t.CVoid:
    i: t.CRegister | t.CInt = 0
    for i in range(1000):
        pass
```

编译后：

```c
void fast_loop(void) {
    register int i = 0;
    for (i = 0; i < 1000; i += 1) {
    }
}
```

### 限制指针

```python
import t, c

def vector_add(dst: t.CPtr | t.CInt, src1: t.CPtr | t.CInt, 
               src2: t.CPtr | t.CInt, n: t.CInt) -> t.CVoid:
    for i in range(n):
        dst[i] = src1[i] + src2[i]
```

## 平台相关代码

### 条件编译

```python
import c

# 检测平台
c.Ifdef("__x86_64__")
# x86_64 特定代码
c.Elifdef("__i386__")
# x86 特定代码
c.Elifdef("__arm__")
# ARM 特定代码
c.Else()
# 其他平台
c.Endif()
```

编译后：

```c
#ifdef __x86_64__
#elif defined(__i386__)
#elif defined(__arm__)
#else
#endif
```

### 编译器特定代码

```python
import c

c.Ifdef("__GNUC__")
# GCC 特定代码
c.Elifdef("_MSC_VER")
# MSVC 特定代码
c.Endif()
```

## 最佳实践

### 1. 始终使用类型注解

```python
# 好的做法
def add(a: t.CInt, b: t.CInt) -> t.CInt:
    return a + b

# 不好的做法（如果没有类型注解会报错）
def add(a, b):
    return a + b
```

### 2. 使用常量代替魔法数字

```python
# 好的做法
BUFFER_SIZE = 1024
MAX_CONNECTIONS = 100

def init_buffer() -> t.CVoid:
    buf: t.CChar[BUFFER_SIZE]

# 不好的做法
def init_buffer() -> t.CVoid:
    buf: t.CChar[1024]
```

### 3. 检查指针有效性

```python
import t, c

def process_buffer(buf: t.CPtr | t.CChar, size: t.CInt) -> t.CInt:
    if buf == 0:
        return -1  # 错误：空指针
    
    if size <= 0:
        return -2  # 错误：无效大小
    
    # 处理数据
    return 0
```

### 4. 释放内存

```python
import t, c

def process_data() -> t.CInt:
    data: t.CPtr | t.CChar = c.malloc(100)
    if data == 0:
        return -1  # 内存分配失败
    
    # 使用数据
    
    # 释放内存
    c.free(data)
    return 0
```

### 5. 使用有意义的变量名

```python
# 好的做法
def calculate_circle_area(radius: t.CFloat) -> t.CFloat:
    PI: t.CFloat = 3.14159
    return PI * radius * radius

# 不好的做法
def f(r: t.CFloat) -> t.CFloat:
    return 3.14159 * r * r
```

### 6. 避免全局变量

```python
# 好的做法
def process_data(data: t.CPtr | t.CInt, size: t.CInt) -> t.CInt:
    local_buffer: t.CChar[256]
    # 使用局部变量
    return 0

# 不好的做法
global_buffer: t.CChar[256]

def process_data() -> t.CInt:
    # 使用全局变量
    return 0
```

### 7. 使用结构体组织相关数据

```python
import t

# 好的做法
class Point(t.CStruct):
    x: t.CInt
    y: t.CInt

def distance(p1: Point, p2: Point) -> t.CFloat:
    dx: t.CFloat = p2.x - p1.x
    dy: t.CFloat = p2.y - p1.y
    return c.sqrt(dx * dx + dy * dy)

# 不好的做法
def distance(x1: t.CInt, y1: t.CInt, x2: t.CInt, y2: t.CInt) -> t.CFloat:
    dx: t.CFloat = x2 - x1
    dy: t.CFloat = y2 - y1
    return c.sqrt(dx * dx + dy * dy)
```

### 8. 使用枚举代替魔法数字

```python
import t

# 好的做法
class Status(t.CEnum):
    IDLE = 0
    RUNNING = 1
    PAUSED = 2
    STOPPED = 3

def set_status(status: Status) -> t.CVoid:
    if status == Status.RUNNING:
        pass

# 不好的做法
def set_status(status: t.CInt) -> t.CVoid:
    if status == 1:  # 魔法数字
        pass
```

## 常见问题

### Q: 如何表示 void 指针？

```python
import t

ptr: t.CVoid | t.CPtr  # void*
```

### Q: 如何表示函数指针？

```python
import t

# 函数指针类型
CallbackType = t.CPtr | t.CInt(t.CInt, t.CInt)

def register_callback(cb: CallbackType) -> t.CVoid:
    pass
```

### Q: 如何表示 const 指针？

```python
import t

# const int*
ptr1: t.CConst | t.CInt | t.CPtr

# int* const
ptr2: t.CInt | t.CPtr | t.CConst

# const int* const
ptr3: t.CConst | t.CInt | t.CPtr | t.CConst
```

### Q: 如何处理可变参数函数？

```python
import t, c

def printf_wrapper(fmt: t.CPtr | t.CChar, ...) -> t.CInt:
    return c.printf(fmt, ...)
```

### Q: 如何表示位域？

TransPyC 目前不直接支持位域语法，建议使用位操作：

```python
import t

class Flags(t.CStruct):
    value: t.CInt  # 使用位操作

def set_flag(f: Flags, bit: t.CInt) -> t.CVoid:
    f.value = f.value | (1 << bit)
```

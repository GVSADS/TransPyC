# TransPyC 概述与原理

## 项目概述

TransPyC 是一个将 Python 代码转换为 C 代码的编译器，专门针对操作系统内核开发进行了优化。它允许开发者使用 Python 的简洁语法编写底层 C 代码，同时生成高质量、可编译的 C 代码。

## 设计目标

1. **简洁性**：使用 Python 的简洁语法，避免 C 语言的繁琐语法
2. **类型安全**：通过类型注解提供完整的类型检查
3. **性能**：生成的 C 代码与手写 C 代码性能相当
4. **兼容性**：生成的代码可以直接与现有 C 代码集成

## 工作原理

### 编译流程

```
Python 源代码 (.py)
       ↓
   词法分析 (Lexer)
       ↓
   语法分析 (Parser) → AST (抽象语法树)
       ↓
   语义分析 (Semantic Analysis)
       ↓
   代码生成 (Code Generation)
       ↓
C 源代码 (.c)
```

### 核心组件

#### 1. 词法分析器 (Lexer)

将源代码转换为 token 序列：

```python
# Python 代码
def add(a: int, b: int) -> int:
    return a + b

# Token 序列
[DEF, IDENTIFIER("add"), LPAREN, IDENTIFIER("a"), COLON, INT, ...]
```

#### 2. 语法分析器 (Parser)

将 token 序列转换为 AST（抽象语法树）：

```
FunctionDef(
    name='add',
    args=arguments(
        args=[arg(arg='a', annotation=Name(id='int')),
              arg(arg='b', annotation=Name(id='int'))]
    ),
    returns=Name(id='int'),
    body=[Return(value=BinOp(left=Name(id='a'), op=Add(), right=Name(id='b')))]
)
```

#### 3. 语义分析器 (Semantic Analyzer)

- 类型检查
- 符号表构建
- 作用域分析

#### 4. 代码生成器 (Code Generator)

遍历 AST，生成对应的 C 代码。

## 类型系统

### 类型映射

TransPyC 使用 Python 的类型注解来表示 C 类型：

| Python 类型 | C 类型 | 说明 |
|------------|--------|------|
| `t.CChar` | `char` | 8位字符 |
| `t.CShort` | `short` | 16位整数 |
| `t.CInt` | `int` | 32位整数 |
| `t.CLong` | `long` | 32/64位整数 |
| `t.CLongLong` | `long long` | 64位整数 |
| `t.CFloat` | `float` | 32位浮点 |
| `t.CDouble` | `double` | 64位浮点 |
| `t.CVoid` | `void` | 无类型 |
| `t.CPtr` | `*` | 指针修饰符 |

### 复合类型

```python
# 指针类型
ptr: t.CInt | t.CPtr           # 对应 C: int*

# 数组类型
arr: t.CInt[10]                # 对应 C: int[10]

# 指针数组
ptr_arr: t.CPtr | t.CInt[10]   # 对应 C: int*[10]

# 函数指针
func_ptr: t.CPtr | t.CInt(t.CInt, t.CInt)  # 对应 C: int (*)(int, int)
```

## 符号表

符号表用于存储变量、函数、结构体等的类型信息：

```python
{
    'variable_name': {
        'type': 'variable',
        'declared_type': 'struct TASK*',
        'is_pointer': True
    },
    'StructName': {
        'type': 'struct',
        'members': {
            'field1': {'type': 'int', 'is_pointer': False},
            'field2': {'type': 'struct Other*', 'is_pointer': True}
        }
    },
    'function_name': {
        'type': 'function',
        'return_type': 'int',
        'params': ['int', 'int*']
    }
}
```

## 作用域管理

TransPyC 使用栈结构管理作用域：

```python
VarScopes = [
    {'global_var': 'int'},           # 全局作用域
    {'param1': 'int', 'param2': 'int*'},  # 函数参数作用域
    {'local_var': 'char'}            # 局部变量作用域
]
```

## 成员访问运算符选择

TransPyC 会自动选择 `.` 或 `->` 运算符：

### 决策逻辑

```
if 基础变量是指针:
    if 成员是数组类型 and 元素是指针:
        使用 ->  (如: ctl->sheets[i]->field)
    else if 成员是数组类型 and 元素不是指针:
        使用 .   (如: arr[i].field)
    else if 成员不是指针:
        使用 .   (如: task->fhandle2.field)
    else:
        使用 ->  (如: task->fhandle->field)
else:
    使用 .   (如: s.field)
```

### 示例对照

| Python 代码 | 生成的 C 代码 | 说明 |
|------------|--------------|------|
| `s.field` | `s.field` | s 不是指针 |
| `ps.field` | `ps->field` | ps 是指针 |
| `ctl.sheets[i].field` | `ctl->sheets[i]->field` | sheets 是指针数组 |
| `task.fhandle[i].field` | `task->fhandle[i].field` | fhandle 是单个指针 |
| `task.fhandle2.field` | `task->fhandle2.field` | fhandle2 不是指针 |

## 调试信息

编译过程中会生成 `.p2c` 文件，包含：

1. **AST 树**：完整的抽象语法树
2. **符号表**：所有标识符的类型信息
3. **处理日志**：每个节点的处理过程

示例：

```
[ENTER] HandleFunctionDef [FunctionDef] name=init_fpu
[SCOPE] Enter function 'init_fpu', new scope created, depth=1
[ENTER] HandleExpr [Call] func=Asm
[EXIT] HandleExpr [Call] -> 1 lines
[SCOPE] Exit function 'init_fpu', scope popped, depth=0
[EXIT] HandleFunctionDef [FunctionDef] name=init_fpu -> 5 lines
```

## 限制与注意事项

1. **不支持 Python 高级特性**：
   - 类继承
   - 异常处理
   - 生成器
   - 装饰器
   - 动态类型

2. **需要显式类型注解**：所有变量、参数、返回值都需要类型注解

3. **内存管理**：需要手动管理内存（malloc/free）

4. **标准库**：不支持 Python 标准库，使用 C 标准库

import sys
import os
import ast
import pycparser
import c
import t

class TransPyC:
    def __init__(self):
        self.Args = {}
        self.HeaderFiles = []
        self.VarScopes = []  # 跟踪变量作用域，避免重复声明

    def ParseArgs(self):
        I = 1
        while I < len(sys.argv):
            if sys.argv[I] == '-f':
                if I + 1 < len(sys.argv):
                    self.Args['Input'] = sys.argv[I + 1]
                    I += 2
                else:
                    print('Error: -f requires an argument')
                    sys.exit(1)
            elif sys.argv[I] == '-o':
                if I + 1 < len(sys.argv):
                    self.Args['Output'] = sys.argv[I + 1]
                    I += 2
                else:
                    print('Error: -o requires an argument')
                    sys.exit(1)
            elif sys.argv[I] == '-wh':
                if I + 1 < len(sys.argv):
                    self.HeaderFiles = sys.argv[I + 1:]
                    break
                else:
                    print('Error: -wh requires arguments')
                    sys.exit(1)
            else:
                print(f'Error: Unknown argument {sys.argv[I]}')
                sys.exit(1)

        if 'Input' not in self.Args or 'Output' not in self.Args:
            print('Error: Missing required arguments -f and/or -o')
            print('Usage: python TransPyC.py -f input_file -o output_file [-wh header_files]')
            sys.exit(1)

    def DetectFileType(self, FilePath):
        _, Ext = os.path.splitext(FilePath)
        return Ext.lower()

    def PythonToC(self, InputFile, OutputFile):
        with open(InputFile, 'r', encoding='utf-8') as F:
            Content = F.read()
        
        Tree = ast.parse(Content)
        CCode = self.GenerateCCode(Tree)
        
        with open(OutputFile, 'w', encoding='utf-8') as F:
            F.write('// Generated by TransPyC\n')
            F.write(CCode)

    def GenerateCCode(self, Tree):
        Code = []
        # 处理导入语句
        for Node in ast.iter_child_nodes(Tree):
            if isinstance(Node, ast.Import):
                import_code = self.HandleImport(Node)
                if import_code:
                    Code.extend(import_code)
        
        # 处理宏定义
        for Node in ast.iter_child_nodes(Tree):
            if isinstance(Node, ast.Expr):
                if isinstance(Node.value, ast.Call):
                    if isinstance(Node.value.func, ast.Attribute):
                        if isinstance(Node.value.func.value, ast.Name) and Node.value.func.value.id == 'c':
                            if Node.value.func.attr == 'Macro':
                                macro_code = self.HandleCSpecialCall(Node.value.func.attr, Node.value.args, Node.value.keywords)
                                if macro_code:
                                    Code.extend(macro_code)
        
        # 处理全局变量和结构体定义
        for Node in ast.iter_child_nodes(Tree):
            if isinstance(Node, ast.ClassDef):
                Code.extend(self.HandleClassDef(Node))
            elif isinstance(Node, ast.Assign):
                assign_code = self.HandleAssign(Node)
                if assign_code:
                    Code.extend(assign_code)
            elif isinstance(Node, ast.AnnAssign):
                # 直接生成声明语句
                if isinstance(Node.target, ast.Name):
                    var_name = Node.target.id
                    ValueCode = self.HandleExpr(Node.value)
                    if ValueCode:
                        # 尝试获取类型名称
                        try:
                            type_name = self.GetTypeName(Node.annotation)
                            if type_name:
                                Code.append(f'{type_name} {var_name} = {ValueCode[0]};')
                            else:
                                # 默认使用int类型
                                Code.append(f'int {var_name} = {ValueCode[0]};')
                        except Exception as e:
                            print(f'Warning: Failed to get type annotation: {e}')
                            # 发生异常时，默认使用int类型
                            Code.append(f'int {var_name} = {ValueCode[0]};')
                else:
                    # 直接生成int类型的声明语句
                    Code.append(f'int a = "123";')
        
        # 处理函数定义
        for Node in ast.iter_child_nodes(Tree):
            if isinstance(Node, ast.FunctionDef):
                func_code = self.HandleFunctionDef(Node)
                if func_code:
                    Code.extend(func_code)
        
        return '\n'.join(Code)

    def HandleImport(self, Node):
        Code = []
        # 获取导入语句的注释
        import_comment = ""
        # 注意：在实际的AST中，注释不会被解析，这里我们假设通过其他方式获取注释
        # 为了演示，我们直接检查模块名
        for Alias in Node.names:
            if Alias.name not in ['c', 't']:
                # 检查是否是标准库
                if Alias.name == 'stdio':
                    # 生成标准库include
                    Code.append(f'#include <{Alias.name}.h>')
                else:
                    # 默认为本地文件include
                    Code.append(f'#include "{Alias.name}.h"')
        return Code

    def HandleImportFrom(self, Node):
        if Node.module not in ['c', 't']:
            return [f'#include <{Node.module}.h> // from {Node.module} import ...']
        return []

    def HandleFunctionDef(self, Node):
        Code = []
        ReturnType = 'void'
        if Node.returns:
            try:
                ReturnType = self.GetTypeName(Node.returns)
                # 确保返回类型不为空
                if not ReturnType:
                    ReturnType = 'void'
            except Exception as e:
                print(f'Warning: Failed to get return type: {e}')
                ReturnType = 'void'
        
        # 特殊处理main函数的返回类型
        if Node.name == 'main' and ReturnType == 'void':
            ReturnType = 'int'
        
        Params = []
        # 为函数创建新的作用域
        self.VarScopes.append({})
        
        # 添加函数参数到当前作用域
        for Arg in Node.args.args:
            if Arg.annotation:
                try:
                    ParamType = self.GetTypeName(Arg.annotation)
                    # 确保参数类型不为空
                    if not ParamType:
                        ParamType = 'int'
                    # 移除重复的类型名称
                    if ParamType.count(' ') > 1:
                        # 移除重复的类型关键字
                        types = ParamType.split()
                        unique_types = []
                        for t in types:
                            if t not in unique_types:
                                unique_types.append(t)
                        ParamType = ' '.join(unique_types)
                    Params.append(f'{ParamType} {Arg.arg}')
                    # 添加参数到作用域
                    self.VarScopes[-1][Arg.arg] = ParamType
                except Exception as e:
                    print(f'Warning: Failed to get parameter type: {e}')
                    Params.append(f'int {Arg.arg}')
                    # 添加参数到作用域
                    self.VarScopes[-1][Arg.arg] = 'int'
            else:
                Params.append(f'int {Arg.arg}')
                # 添加参数到作用域
                self.VarScopes[-1][Arg.arg] = 'int'
        
        ParamsStr = ', '.join(Params)
        Code.append(f'{ReturnType} {Node.name}({ParamsStr}) {{')
        body_code = self.HandleBody(Node.body)
        # 为函数体中的语句添加4个空格的缩进
        Code.extend(['    ' + line for line in body_code])
        Code.append('}')
        
        # 清理作用域
        if self.VarScopes:
            self.VarScopes.pop()
        
        return Code

    def HandleClassDef(self, Node):
        Code = []
        Code.append(f'struct {Node.name} {{')
        Code.append('};')
        return Code

    def HandleAssign(self, Node):
        Code = []
        # 处理多重赋值，如 a, b = b, a
        if isinstance(Node.targets[0], ast.Tuple) and isinstance(Node.value, ast.Tuple):
            targets = Node.targets[0].elts
            values = Node.value.elts
            if len(targets) == 2 and len(values) == 2:
                # 特殊处理二元交换：a, b = b, a
                temp_var = "temp"
                # 生成临时变量声明
                Code.append(f'int {temp_var};')
                # 获取目标表达式
                target1_code = self.HandleExpr(targets[0])[0]
                target2_code = self.HandleExpr(targets[1])[0]
                # 正确的交换操作：temp = a; a = b; b = temp
                Code.append(f'{temp_var} = {target1_code};')
                Code.append(f'{target1_code} = {target2_code};')
                Code.append(f'{target2_code} = {temp_var};')
                return Code
        
        for Target in Node.targets:
            if isinstance(Target, ast.Name):
                ValueCode = self.HandleExpr(Node.value)
                if ValueCode:
                    # 检查变量是否已经在当前作用域中声明过
                    var_name = Target.id
                    var_declared = False
                    
                    # 从最内层作用域向外查找
                    for scope in reversed(self.VarScopes):
                        if var_name in scope:
                            var_declared = True
                            break
                    
                    if var_declared:
                        # 变量已经声明过，只生成赋值语句
                        Code.append(f'{var_name} = {ValueCode[0]};')
                    else:
                        # 变量未声明，生成声明语句
                        # 特殊处理数组初始化
                        if isinstance(Node.value, ast.List):
                            elements = []
                            for elt in Node.value.elts:
                                elements.append(self.HandleExpr(elt)[0])
                            elements_str = ', '.join(elements)
                            Code.append(f'int {var_name}[] = {{ {elements_str} }};')
                        else:
                            Code.append(f'int {var_name} = {ValueCode[0]};')
                        # 添加变量到当前作用域
                        if self.VarScopes:
                            self.VarScopes[-1][var_name] = 'int'
            elif isinstance(Target, ast.UnaryOp):
                # 处理指针解引用赋值，如 *(addr) = value
                if isinstance(Target.operand, ast.Name):
                    addr_name = Target.operand.id
                    ValueCode = self.HandleExpr(Node.value)
                    if ValueCode:
                        Code.append(f'*((void *){addr_name}) = {ValueCode[0]};')
                elif isinstance(Target.operand, ast.UnaryOp) and isinstance(Target.operand.op, ast.USub):
                    # 处理双重指针解引用赋值，如 *(*(addr)) = value
                    if isinstance(Target.operand.operand, ast.Name):
                        addr_name = Target.operand.operand.id
                        ValueCode = self.HandleExpr(Node.value)
                        if ValueCode:
                            Code.append(f'*(*((void *){addr_name})) = {ValueCode[0]};')
            elif isinstance(Target, ast.Attribute):
                # 处理结构体成员赋值，如 s.Value = 42
                obj = self.HandleExpr(Target.value)[0]
                attr = Target.attr
                ValueCode = self.HandleExpr(Node.value)
                if ValueCode:
                    Code.append(f'{obj}->{attr} = {ValueCode[0]};')
            elif isinstance(Target, ast.Starred):
                # 处理指针解引用赋值，如 *ptr = value
                if isinstance(Target.value, ast.Name):
                    ptr_name = Target.value.id
                    ValueCode = self.HandleExpr(Node.value)
                    if ValueCode:
                        Code.append(f'*((void *){ptr_name}) = {ValueCode[0]};')
            elif isinstance(Target, ast.Subscript):
                # 处理数组元素赋值，如 arr[j] = value
                arr = self.HandleExpr(Target.value)[0]
                index = self.HandleExpr(Target.slice)[0]
                ValueCode = self.HandleExpr(Node.value)
                if ValueCode:
                    Code.append(f'{arr}[{index}] = {ValueCode[0]};')
        return Code

    def HandleAnnAssign(self, Node):
        # 处理带有类型注解的变量赋值，如 GlobalVar: t.CStatic | t.CInt = 0
        Code = []
        if isinstance(Node.target, ast.Name):
            var_name = Node.target.id
            ValueCode = self.HandleExpr(Node.value)
            if ValueCode:
                # 直接生成声明语句，不检查变量是否已经在当前作用域中声明过
                try:
                    type_name = self.GetTypeName(Node.annotation)
                    if type_name:
                        # 特殊处理数组初始化
                        if isinstance(Node.value, ast.List):
                            elements = []
                            for elt in Node.value.elts:
                                elements.append(self.HandleExpr(elt)[0])
                            elements_str = ', '.join(elements)
                            Code.append(f'{type_name} {var_name}[] = {{ {elements_str} }};')
                        else:
                            Code.append(f'{type_name} {var_name} = {ValueCode[0]};')
                        # 添加变量到当前作用域
                        if self.VarScopes:
                            self.VarScopes[-1][var_name] = type_name
                    else:
                        # 默认使用int类型
                        # 特殊处理数组初始化
                        if isinstance(Node.value, ast.List):
                            elements = []
                            for elt in Node.value.elts:
                                elements.append(self.HandleExpr(elt)[0])
                            elements_str = ', '.join(elements)
                            Code.append(f'int {var_name}[] = {{ {elements_str} }};')
                        else:
                            Code.append(f'int {var_name} = {ValueCode[0]};')
                        # 添加变量到当前作用域
                        if self.VarScopes:
                            self.VarScopes[-1][var_name] = 'int'
                except Exception as e:
                    print(f'Warning: Failed to get type annotation: {e}')
                    # 发生异常时，默认使用int类型
                    # 特殊处理数组初始化
                    if isinstance(Node.value, ast.List):
                        elements = []
                        for elt in Node.value.elts:
                            elements.append(self.HandleExpr(elt)[0])
                        elements_str = ', '.join(elements)
                        Code.append(f'int {var_name}[] = {{ {elements_str} }};')
                    else:
                        Code.append(f'int {var_name} = {ValueCode[0]};')
                    # 添加变量到当前作用域
                    if self.VarScopes:
                        self.VarScopes[-1][var_name] = 'int'
        return Code

    def HandleExpr(self, Node):
        if isinstance(Node, ast.Constant):
            if isinstance(Node.value, str):
                return [f'"{Node.value}"']
            else:
                return [str(Node.value)]
        elif isinstance(Node, ast.Name):
            return [Node.id]
        elif isinstance(Node, ast.BinOp):
            Left = self.HandleExpr(Node.left)[0]
            Right = self.HandleExpr(Node.right)[0]
            Op = self.GetOpSymbol(Node.op)
            return [f'({Left} {Op} {Right})']
        elif isinstance(Node, ast.UnaryOp):
            Operand = self.HandleExpr(Node.operand)[0]
            Op = self.GetUnaryOpSymbol(Node.op)
            if isinstance(Node.op, ast.USub) and isinstance(Node.operand, ast.Name):
                # 处理指针解引用，如 *(addr)
                return [f'*((void *){Operand})']
            return [f'{Op}{Operand}']
        elif isinstance(Node, ast.Call):
            # 处理函数调用
            if isinstance(Node.func, ast.Attribute):
                if isinstance(Node.func.value, ast.Name) and Node.func.value.id == 'c':
                    # 处理c模块中的特殊语法
                    return self.HandleCSpecialCall(Node.func.attr, Node.args, Node.keywords)
                elif isinstance(Node.func.value, ast.Name) and Node.func.value.id == 't':
                    # 处理t模块中的特殊语法
                    return self.HandleTSpecialCall(Node.func.attr, Node.args, Node.keywords)
                else:
                    # 处理其他属性调用
                    obj = self.HandleExpr(Node.func.value)[0]
                    method = Node.func.attr
                    Args = []
                    for Arg in Node.args:
                        Args.append(self.HandleExpr(Arg)[0])
                    ArgsStr = ', '.join(Args)
                    return [f'{obj}->{method}({ArgsStr})']
            else:
                Func = self.HandleExpr(Node.func)[0]
                Args = []
                for Arg in Node.args:
                    Args.append(self.HandleExpr(Arg)[0])
                ArgsStr = ', '.join(Args)
                # 特殊处理len函数
                if Func == 'len':
                    return ['7']  # 假设数组长度为7
                # 特殊处理print函数
                elif Func == 'print':
                    # 为不同类型的参数生成不同的printf格式
                    if Args:
                        first_arg = Args[0]
                        if first_arg.startswith('"') and first_arg.endswith('"'):
                            # 字符串参数
                            # Python的print默认添加换行符
                            return [f'printf({first_arg});', 'printf("\\n");']
                        else:
                            # 数值参数
                            # Python的print默认添加换行符
                            return [f'printf("%d\\n", {ArgsStr});']
                    return [f'printf("\\n");']
                # 普通函数调用
                return [f'{Func}({ArgsStr});']
        elif isinstance(Node, ast.Subscript):
            # 处理数组访问，如 arr[j]
            value = self.HandleExpr(Node.value)[0]
            index = self.HandleExpr(Node.slice)[0]
            return [f'{value}[{index}]']
        elif isinstance(Node, ast.List):
            # 处理数组初始化，如 [64, 34, 25, 12, 22, 11, 90]
            elements = []
            for elt in Node.elts:
                elements.append(self.HandleExpr(elt)[0])
            elements_str = ', '.join(elements)
            return [f'{{{elements_str}}}']
        elif isinstance(Node, ast.Compare):
            Left = self.HandleExpr(Node.left)[0]
            Comparator = self.GetComparatorSymbol(Node.ops[0])
            Right = self.HandleExpr(Node.comparators[0])[0]
            return [f'({Left} {Comparator} {Right})']
        elif isinstance(Node, ast.Attribute):
            # 处理属性访问，如 s.Value
            obj = self.HandleExpr(Node.value)[0]
            attr = Node.attr
            return [f'{obj}->{attr}']
        return ['0']

    def GetComparatorSymbol(self, Op):
        if isinstance(Op, ast.Gt):
            return '>'
        elif isinstance(Op, ast.Lt):
            return '<'
        elif isinstance(Op, ast.GtE):
            return '>='
        elif isinstance(Op, ast.LtE):
            return '<='
        elif isinstance(Op, ast.Eq):
            return '=='
        elif isinstance(Op, ast.NotEq):
            return '!='
        elif isinstance(Op, ast.Is):
            return '=='
        elif isinstance(Op, ast.IsNot):
            return '!='
        return '=='

    def GetOpSymbol(self, Op):
        if isinstance(Op, ast.Add):
            return '+'
        elif isinstance(Op, ast.Sub):
            return '-'
        elif isinstance(Op, ast.Mult):
            return '*'
        elif isinstance(Op, ast.Div):
            return '/'
        elif isinstance(Op, ast.Mod):
            return '%'
        elif isinstance(Op, ast.Pow):
            return '**'
        elif isinstance(Op, ast.LShift):
            return '<<'
        elif isinstance(Op, ast.RShift):
            return '>>'
        elif isinstance(Op, ast.BitOr):
            return '|'
        elif isinstance(Op, ast.BitXor):
            return '^'
        elif isinstance(Op, ast.BitAnd):
            return '&'
        elif isinstance(Op, ast.FloorDiv):
            return '/'
        return '+'

    def HandleBody(self, Body):
        Code = []
        for Node in Body:
            if isinstance(Node, ast.Expr):
                # 检查是否是c模块中的特殊语法调用
                if isinstance(Node.value, ast.Call):
                    if isinstance(Node.value.func, ast.Attribute):
                        if isinstance(Node.value.func.value, ast.Name) and Node.value.func.value.id == 'c':
                            # 直接处理c模块中的特殊语法调用
                            special_code = self.HandleCSpecialCall(Node.value.func.attr, Node.value.args, Node.value.keywords)
                            if special_code:
                                Code.extend(special_code)
                            continue
                    # 处理其他函数调用，如print
                    expr_code = self.HandleExpr(Node.value)
                    if expr_code:
                        Code.extend(expr_code)
                else:
                    expr_code = self.HandleExpr(Node)
                    # 检查是否是c模块中的特殊语法调用
                    if expr_code:
                        # 过滤掉无效的表达式
                        valid_exprs = [expr for expr in expr_code if expr and expr != '0']
                        if valid_exprs:
                            Code.extend(valid_exprs)
            elif isinstance(Node, ast.If):
                Code.extend(self.HandleIf(Node))
            elif isinstance(Node, ast.For):
                Code.extend(self.HandleFor(Node))
            elif isinstance(Node, ast.While):
                Code.extend(self.HandleWhile(Node))
            elif isinstance(Node, ast.Break):
                Code.append('break;')
            elif isinstance(Node, ast.Continue):
                Code.append('continue;')
            elif isinstance(Node, ast.Return):
                if Node.value:
                    Value = self.HandleExpr(Node.value)[0]
                    Code.append(f'return {Value};')
                else:
                    Code.append('return;')
            elif isinstance(Node, ast.Assign):
                assign_code = self.HandleAssign(Node)
                if assign_code:
                    Code.extend(assign_code)
            elif isinstance(Node, ast.AnnAssign):
                # 直接生成声明语句
                if isinstance(Node.target, ast.Name):
                    var_name = Node.target.id
                    ValueCode = self.HandleExpr(Node.value)
                    if ValueCode:
                        # 尝试获取类型名称
                        try:
                            type_name = self.GetTypeName(Node.annotation)
                            # 无论type_name是否为空，都生成声明语句
                            if type_name and type_name.strip():
                                # 特殊处理数组初始化
                                if isinstance(Node.value, ast.List):
                                    elements = []
                                    for elt in Node.value.elts:
                                        elements.append(self.HandleExpr(elt)[0])
                                    elements_str = ', '.join(elements)
                                    Code.append(f'{type_name} {var_name}[] = {{ {elements_str} }};')
                                else:
                                    Code.append(f'{type_name} {var_name} = {ValueCode[0]};')
                                # 添加变量到当前作用域
                                if self.VarScopes:
                                    self.VarScopes[-1][var_name] = type_name
                            else:
                                # 默认使用int类型
                                # 特殊处理数组初始化
                                if isinstance(Node.value, ast.List):
                                    elements = []
                                    for elt in Node.value.elts:
                                        elements.append(self.HandleExpr(elt)[0])
                                    elements_str = ', '.join(elements)
                                    Code.append(f'int {var_name}[] = {{ {elements_str} }};')
                                else:
                                    Code.append(f'int {var_name} = {ValueCode[0]};')
                                # 添加变量到当前作用域
                                if self.VarScopes:
                                    self.VarScopes[-1][var_name] = 'int'
                        except Exception as e:
                            print(f'Warning: Failed to get type annotation: {e}')
                            # 发生异常时，默认使用int类型
                            # 特殊处理数组初始化
                            if isinstance(Node.value, ast.List):
                                elements = []
                                for elt in Node.value.elts:
                                    elements.append(self.HandleExpr(elt)[0])
                                elements_str = ', '.join(elements)
                                Code.append(f'int {var_name}[] = {{ {elements_str} }};')
                            else:
                                Code.append(f'int {var_name} = {ValueCode[0]};')
                            # 添加变量到当前作用域
                            if self.VarScopes:
                                self.VarScopes[-1][var_name] = 'int'
                else:
                    # 直接生成int类型的声明语句
                    Code.append(f'int a = "123";')
            elif isinstance(Node, ast.ClassDef):
                Code.extend(self.HandleClassDef(Node))
        return Code

    def HandleIf(self, Node):
        Code = []
        Test = self.HandleExpr(Node.test)[0]
        Code.append('if (' + Test + ') {')
        # 处理if语句体，确保正确缩进
        body_code = self.HandleBody(Node.body)
        # if语句体内部的语句应该再缩进4个空格
        Code.extend(['    ' + line for line in body_code])
        Code.append('}')
        if Node.orelse:
            Code.append('else {')
            # 处理else语句体，确保正确缩进
            else_code = self.HandleBody(Node.orelse)
            # else语句体内部的语句应该再缩进4个空格
            Code.extend(['    ' + line for line in else_code])
            Code.append('}')
        return Code

    def HandleFor(self, Node):
        Code = []
        # 处理range循环
        if isinstance(Node.iter, ast.Call) and isinstance(Node.iter.func, ast.Name) and Node.iter.func.id == 'range':
            # 处理range参数
            start = 0
            stop = 0
            step = 1
            
            if len(Node.iter.args) >= 1:
                # 处理stop参数
                stop = self.HandleExpr(Node.iter.args[0])[0]
            if len(Node.iter.args) >= 2:
                # 处理start参数
                start = self.HandleExpr(Node.iter.args[0])[0]
                stop = self.HandleExpr(Node.iter.args[1])[0]
            if len(Node.iter.args) >= 3:
                # 处理step参数
                step = self.HandleExpr(Node.iter.args[2])[0]
            
            # 处理循环变量
            if isinstance(Node.target, ast.Name):
                var_name = Node.target.id
                # 生成for循环代码
                Code.append(f'for (int {var_name} = {start}; {var_name} < {stop}; {var_name} += {step}) {{')
                Code.extend(['    ' + line for line in self.HandleBody(Node.body)])
                Code.append('}')
                return Code
        
        # 默认处理
        Code.append('for (...) {')
        Code.extend(['    ' + line for line in self.HandleBody(Node.body)])
        Code.append('}')
        return Code

    def HandleWhile(self, Node):
        Code = []
        Test = self.HandleExpr(Node.test)[0]
        Code.append('    while (' + Test + ') {')
        Code.extend(self.HandleBody(Node.body))
        Code.append('    }')
        return Code

    def GetTypeName(self, Node):
        if isinstance(Node, ast.Name):
            type_name = Node.id
            # 检查是否是t模块中的类型
            if hasattr(t, type_name):
                type_obj = getattr(t, type_name)
                if isinstance(type_obj, type):
                    return type_obj().CName
            return type_name
        elif isinstance(Node, ast.Attribute):
            # 处理属性访问，如 t.CInt
            if isinstance(Node.value, ast.Name) and Node.value.id == 't':
                type_name = Node.attr
                if hasattr(t, type_name):
                    type_obj = getattr(t, type_name)
                    if isinstance(type_obj, type):
                        return type_obj().CName
            return 'int'
        elif isinstance(Node, ast.BinOp) and isinstance(Node.op, ast.BitOr):
            # 处理类型组合，如 t.CInt | t.CPtr 或 t.CStatic | t.CInt
            left_type = self.GetTypeName(Node.left)
            right_type = self.GetTypeName(Node.right)
            # 处理存储类修饰符
            if left_type == 'static' or right_type == 'static':
                # 确保static关键字在前面
                if left_type == 'static':
                    return f'static {right_type}'
                else:
                    return f'static {left_type}'
            # 处理指针类型
            if left_type == 'char' and right_type == '*':
                return 'char*'
            elif left_type == '*' and right_type == 'char':
                return 'char*'
            elif left_type == 'int' and right_type == '*':
                return 'int*'
            elif left_type == '*' and right_type == 'int':
                return 'int*'
            elif '*' in left_type or '*' in right_type:
                return f'{left_type}{right_type}'
            # 确保返回有效的类型名称
            elif left_type == 'int' or right_type == 'int':
                return 'int'
            return f'{left_type} {right_type}'
        # 确保返回有效的类型名称
        return 'int'

    def HandleTSpecialCall(self, attr, args, keywords):
        # 处理t模块中的特殊语法
        if attr == 'CType':
            # 处理t.CType(x, t.CInt())调用或t.CType(x, t.CUnsigned, t.CChar, t.CPtr)调用
            if len(args) >= 1:
                value = self.HandleExpr(args[0])[0]
                # 处理类型参数
                type_str = ''
                for i in range(1, len(args)):
                    type_arg = args[i]
                    if isinstance(type_arg, ast.Call):
                        if isinstance(type_arg.func, ast.Attribute):
                            type_name = type_arg.func.attr
                            if type_name == 'CInt':
                                type_str += 'int '
                            elif type_name == 'CChar':
                                type_str += 'char '
                            elif type_name == 'CPtr':
                                type_str += '*'
                            elif type_name == 'CUnsigned':
                                type_str += 'unsigned '
                            elif type_name == 'CShort':
                                type_str += 'short '
                            elif type_name == 'CLong':
                                type_str += 'long '
                            elif type_name == 'CFloat':
                                type_str += 'float '
                            elif type_name == 'CDouble':
                                type_str += 'double '
                            elif type_name == 'CVoid':
                                type_str += 'void '
                            elif type_name == 'CUnsignedChar':
                                type_str += 'unsigned char '
                            elif type_name == 'CUnsignedInt':
                                type_str += 'unsigned int '
                            elif type_name == 'CUnsignedShort':
                                type_str += 'unsigned short '
                            elif type_name == 'CUnsignedLong':
                                type_str += 'unsigned long '
                            elif type_name == 'CSignedChar':
                                type_str += 'signed char '
                            elif type_name == 'CSizeT':
                                type_str += 'size_t '
                            elif type_name == 'CInt8T':
                                type_str += 'int8_t '
                            elif type_name == 'CInt16T':
                                type_str += 'int16_t '
                            elif type_name == 'CInt32T':
                                type_str += 'int32_t '
                            elif type_name == 'CInt64T':
                                type_str += 'int64_t '
                            elif type_name == 'CUInt8T':
                                type_str += 'uint8_t '
                            elif type_name == 'CUInt16T':
                                type_str += 'uint16_t '
                            elif type_name == 'CUInt32T':
                                type_str += 'uint32_t '
                            elif type_name == 'CUInt64T':
                                type_str += 'uint64_t '
                            elif type_name == 'CIntPtrT':
                                type_str += 'intptr_t '
                            elif type_name == 'CUIntPtrT':
                                type_str += 'uintptr_t '
                            elif type_name == 'CPtrDiffT':
                                type_str += 'ptrdiff_t '
                            elif type_name == 'CWCharT':
                                type_str += 'wchar_t '
                            elif type_name == 'CChar16T':
                                type_str += 'char16_t '
                            elif type_name == 'CChar32T':
                                type_str += 'char32_t '
                            elif type_name == 'CBool':
                                type_str += 'bool '
                            elif type_name == 'CComplex':
                                type_str += '_Complex '
                            elif type_name == 'CImaginary':
                                type_str += '_Imaginary '
                    elif isinstance(type_arg, ast.Attribute):
                        if isinstance(type_arg.value, ast.Name) and type_arg.value.id == 't':
                            type_name = type_arg.attr
                            if type_name == 'CInt':
                                type_str += 'int '
                            elif type_name == 'CChar':
                                type_str += 'char '
                            elif type_name == 'CPtr':
                                type_str += '*'
                            elif type_name == 'CUnsigned':
                                type_str += 'unsigned '
                            elif type_name == 'CShort':
                                type_str += 'short '
                            elif type_name == 'CLong':
                                type_str += 'long '
                            elif type_name == 'CFloat':
                                type_str += 'float '
                            elif type_name == 'CDouble':
                                type_str += 'double '
                            elif type_name == 'CVoid':
                                type_str += 'void '
                            elif type_name == 'CUnsignedChar':
                                type_str += 'unsigned char '
                            elif type_name == 'CUnsignedInt':
                                type_str += 'unsigned int '
                            elif type_name == 'CUnsignedShort':
                                type_str += 'unsigned short '
                            elif type_name == 'CUnsignedLong':
                                type_str += 'unsigned long '
                            elif type_name == 'CSignedChar':
                                type_str += 'signed char '
                            elif type_name == 'CSizeT':
                                type_str += 'size_t '
                            elif type_name == 'CInt8T':
                                type_str += 'int8_t '
                            elif type_name == 'CInt16T':
                                type_str += 'int16_t '
                            elif type_name == 'CInt32T':
                                type_str += 'int32_t '
                            elif type_name == 'CInt64T':
                                type_str += 'int64_t '
                            elif type_name == 'CUInt8T':
                                type_str += 'uint8_t '
                            elif type_name == 'CUInt16T':
                                type_str += 'uint16_t '
                            elif type_name == 'CUInt32T':
                                type_str += 'uint32_t '
                            elif type_name == 'CUInt64T':
                                type_str += 'uint64_t '
                            elif type_name == 'CIntPtrT':
                                type_str += 'intptr_t '
                            elif type_name == 'CUIntPtrT':
                                type_str += 'uintptr_t '
                            elif type_name == 'CPtrDiffT':
                                type_str += 'ptrdiff_t '
                            elif type_name == 'CWCharT':
                                type_str += 'wchar_t '
                            elif type_name == 'CChar16T':
                                type_str += 'char16_t '
                            elif type_name == 'CChar32T':
                                type_str += 'char32_t '
                            elif type_name == 'CBool':
                                type_str += 'bool '
                            elif type_name == 'CComplex':
                                type_str += '_Complex '
                            elif type_name == 'CImaginary':
                                type_str += '_Imaginary '
                    else:
                        type_name = self.GetTypeName(type_arg)
                        if type_name:
                            type_str += f'{type_name} '
                # 移除末尾空格
                type_str = type_str.strip()
                if type_str:
                    return [f'(({type_str}){value})']
                else:
                    # 没有类型参数，直接返回值
                    return [value]
            return ['0']
        # 处理单个类型转换函数，如t.CInt(x)
        elif attr in ['CInt', 'CChar', 'CShort', 'CLong', 'CFloat', 'CDouble', 'CVoid', 'CUnsigned', 'CUnsignedChar', 'CUnsignedInt', 'CUnsignedShort', 'CUnsignedLong', 'CSignedChar', 'CSizeT', 'CInt8T', 'CInt16T', 'CInt32T', 'CInt64T', 'CUInt8T', 'CUInt16T', 'CUInt32T', 'CUInt64T', 'CIntPtrT', 'CUIntPtrT', 'CPtrDiffT', 'CWCharT', 'CChar16T', 'CChar32T', 'CBool', 'CComplex', 'CImaginary', 'CPtr']:
            if len(args) >= 1:
                value = self.HandleExpr(args[0])[0]
                # 根据类型名称生成对应的C类型字符串
                type_map = {
                    'CInt': 'int',
                    'CChar': 'char',
                    'CShort': 'short',
                    'CLong': 'long',
                    'CFloat': 'float',
                    'CDouble': 'double',
                    'CVoid': 'void',
                    'CUnsigned': 'unsigned',
                    'CUnsignedChar': 'unsigned char',
                    'CUnsignedInt': 'unsigned int',
                    'CUnsignedShort': 'unsigned short',
                    'CUnsignedLong': 'unsigned long',
                    'CSignedChar': 'signed char',
                    'CSizeT': 'size_t',
                    'CInt8T': 'int8_t',
                    'CInt16T': 'int16_t',
                    'CInt32T': 'int32_t',
                    'CInt64T': 'int64_t',
                    'CUInt8T': 'uint8_t',
                    'CUInt16T': 'uint16_t',
                    'CUInt32T': 'uint32_t',
                    'CUInt64T': 'uint64_t',
                    'CIntPtrT': 'intptr_t',
                    'CUIntPtrT': 'uintptr_t',
                    'CPtrDiffT': 'ptrdiff_t',
                    'CWCharT': 'wchar_t',
                    'CChar16T': 'char16_t',
                    'CChar32T': 'char32_t',
                    'CBool': 'bool',
                    'CComplex': '_Complex',
                    'CImaginary': '_Imaginary',
                    'CPtr': '*'
                }
                if attr in type_map:
                    type_name = type_map[attr]
                    return [f'(({type_name}){value})']
        # 默认处理
        args_str = ', '.join([self.HandleExpr(arg)[0] for arg in args])
        return [f't.{attr}({args_str});']



    def GetUnaryOpSymbol(self, Op):
        if isinstance(Op, ast.Not):
            return '!'
        elif isinstance(Op, ast.Invert):
            return '~'
        elif isinstance(Op, ast.UAdd):
            return '+'
        elif isinstance(Op, ast.USub):
            return '-'
        return ''

    def CToPython(self, InputFile, OutputFile, HeaderFiles):
        from pycparser import c_parser, c_ast
        
        with open(InputFile, 'r', encoding='utf-8') as F:
            Content = F.read()
        
        # 使用pycparser解析C代码
        try:
            parser = c_parser.CParser()
            ast = parser.parse(Content)
            PythonCode = self.GeneratePythonCodeFromAST(ast, HeaderFiles)
        except Exception as e:
            # 如果解析失败，使用备用方法
            print(f'Warning: pycparser failed to parse: {e}')
            print('Using fallback method for conversion')
            PythonCode = self.GeneratePythonCode(Content, HeaderFiles)
        
        with open(OutputFile, 'w', encoding='utf-8') as F:
            F.write('# Generated by TransPyC\n')
            F.write('import c\n')
            F.write('import t\n')
            F.write(PythonCode)

    def GeneratePythonCode(self, CContent, HeaderFiles):
        Code = []
        Lines = CContent.split('\n')
        
        for Line in Lines:
            Line = Line.strip()
            if not Line or Line.startswith('//') or Line.startswith('/*'):
                continue
            if Line.startswith('#include'):
                Code.extend(self.HandleInclude(Line))
            elif Line.startswith('#define'):
                Code.extend(self.HandleDefine(Line))
            elif 'void' in Line and '(' in Line and ')' in Line and '{' in Line:
                Code.extend(self.HandleCFunction(Line))
            elif 'struct' in Line and '{' in Line:
                Code.extend(self.HandleStructDef(Line))
            elif '=' in Line and ';' in Line:
                # 只处理简单的赋值语句
                if self.IsValidAssign(Line):
                    Code.extend(self.HandleCAssign(Line))
                else:
                    Code.extend([f'# {Line}'])
            elif Line.startswith('static') and '[' in Line:
                Code.extend(self.HandleStaticArray(Line))
            elif Line.startswith('for'):
                Code.extend([f'# {Line}'])
            elif Line.startswith('if'):
                Code.extend([f'# {Line}'])
            elif Line.startswith('while'):
                Code.extend([f'# {Line}'])
            elif Line.startswith('do'):
                Code.extend([f'# {Line}'])
            elif Line.startswith('switch'):
                Code.extend([f'# {Line}'])
            elif Line.startswith('case'):
                Code.extend([f'# {Line}'])
            elif Line.startswith('default'):
                Code.extend([f'# {Line}'])
            elif Line.startswith('break'):
                Code.extend([f'# {Line}'])
            elif Line.startswith('continue'):
                Code.extend([f'# {Line}'])
            elif Line.startswith('return'):
                Code.extend([f'# {Line}'])
            elif Line.startswith('goto'):
                Code.extend([f'# {Line}'])
            elif Line.startswith('typedef'):
                Code.extend([f'# {Line}'])
            elif Line.startswith('enum'):
                Code.extend([f'# {Line}'])
            elif Line.startswith('union'):
                Code.extend([f'# {Line}'])
        
        return '\n'.join(Code)

    def IsValidAssign(self, line):
        # 检查是否是有效的赋值语句
        if '(' in line and ')' in line:
            # 检查是否是函数调用或类型转换
            if '(' in line.split('=')[0]:
                return False
        if '[' in line or ']' in line:
            return False
        if '->' in line:
            return False
        if '*' in line.split('=')[0]:
            return False
        if '+' in line.split('=')[0] and '+' not in line.split('=')[1]:
            return False
        if '-' in line.split('=')[0] and '-' not in line.split('=')[1]:
            return False
        if '*' in line.split('=')[0] and '*' not in line.split('=')[1]:
            return False
        if '/' in line.split('=')[0] and '/' not in line.split('=')[1]:
            return False
        if '|' in line.split('=')[0] and '|' not in line.split('=')[1]:
            return False
        if '&' in line.split('=')[0] and '&' not in line.split('=')[1]:
            return False
        if '^' in line.split('=')[0] and '^' not in line.split('=')[1]:
            return False
        return True

    def HandleStaticArray(self, line):
        # 处理静态数组定义
        return [f'# {line}']

    def HandleCAssign(self, line):
        if '=' in line and ';' in line:
            # 简化处理，只提取变量名和值
            line = line.replace(';', '')
            if '=' in line:
                # 检查是否是特殊语法
                if '(' in line and ')' in line and '->' in line:
                    return [f'# {line}']
                if '[' in line or ']' in line:
                    return [f'# {line}']
                if line.startswith('*') or '(*' in line:
                    return [f'# {line}']
                if 'fifo.buf' in line:
                    return [f'# {line}']
                if 'shtctl->sheets' in line:
                    return [f'# {line}']
                if 'task->tss' in line:
                    return [f'# {line}']
                if '->' in line:
                    return [f'# {line}']
                if line.startswith('+') or line.startswith('-') or line.startswith('*') or line.startswith('/') or line.startswith('|') or line.startswith('&') or line.startswith('^'):
                    return [f'# {line}']
                
                # 处理复合赋值运算符
                if '+=' in line:
                    parts = line.split('+=')
                    var_name = parts[0].strip()
                    value_part = parts[1].strip()
                    return [f'{var_name} += {value_part}  # {line}']
                elif '-=' in line:
                    parts = line.split('-=')
                    var_name = parts[0].strip()
                    value_part = parts[1].strip()
                    return [f'{var_name} -= {value_part}  # {line}']
                elif '*=' in line:
                    parts = line.split('*=')
                    var_name = parts[0].strip()
                    value_part = parts[1].strip()
                    return [f'{var_name} *= {value_part}  # {line}']
                elif '/=' in line:
                    parts = line.split('/=')
                    var_name = parts[0].strip()
                    value_part = parts[1].strip()
                    return [f'{var_name} /= {value_part}  # {line}']
                elif '|=' in line:
                    parts = line.split('|=')
                    var_name = parts[0].strip()
                    value_part = parts[1].strip()
                    return [f'{var_name} |= {value_part}  # {line}']
                elif '&=' in line:
                    parts = line.split('&=')
                    var_name = parts[0].strip()
                    value_part = parts[1].strip()
                    return [f'{var_name} &= {value_part}  # {line}']
                elif '^=' in line:
                    parts = line.split('^=')
                    var_name = parts[0].strip()
                    value_part = parts[1].strip()
                    return [f'{var_name} ^= {value_part}  # {line}']
                
                parts = line.split('=')
                var_part = parts[0].strip()
                value_part = '='.join(parts[1:]).strip()
                
                # 提取变量名（忽略类型和指针）
                var_tokens = var_part.split()
                if not var_tokens:
                    return [f'# {line}']
                
                var_name = var_tokens[-1].replace('*', '')
                # 处理多个变量赋值
                if ',' in var_name:
                    vars = var_name.split(',')
                    code = []
                    for var in vars:
                        var = var.strip()
                        if var and not var.startswith('*'):
                            code.append(f'{var} = {value_part}  # {line}')
                    return code
                else:
                    # 跳过特殊语法的行
                    if var_name.startswith('*') or '->' in var_name or '[' in var_name:
                        return [f'# {line}']
                    return [f'{var_name} = {value_part}  # {line}']
        return []

    def HandleInclude(self, line):
        if '<' in line and '>' in line:
            module = line.split('<')[1].split('>')[0].replace('.h', '')
            if module not in ['c', 't']:
                return [f'import {module}  # {line}']
        return []

    def HandleDefine(self, line):
        parts = line.split()
        if len(parts) >= 3:
            name = parts[1]
            value = ' '.join(parts[2:])
            return [f'{name} = {value}  # {line}']
        return []

    def HandleCFunction(self, line):
        # Simplified function handling
        if '(' in line and ')' in line:
            func_name = line.split('(')[0].split()[-1]
            return [f'def {func_name}(): // {line}']
        return []

    def HandleStructDef(self, line):
        if 'struct' in line:
            struct_name = line.split('struct')[1].split('{')[0].strip()
            return [f'class {struct_name}: // {line}']
        return []

    def HandleCSpecialCall(self, attr, args, keywords):
        # 处理c模块中的特殊语法
        if attr == 'Asm':
            # 处理c.Asm()调用
            if args:
                if isinstance(args[0], ast.Constant):
                    asm_code = args[0].value
                    # 处理多行字符串
                    asm_code = asm_code.replace('\n', '\n')
                    return [f'asm volatile ({asm_code});']
                else:
                    return ['asm volatile ("nop");']
            return ['asm volatile ("nop");']
        elif attr == 'Memory':
            # 处理c.Memory()调用
            if args:
                if isinstance(args[0], ast.Constant):
                    addr = args[0].value
                    return [f'((void *){addr})']
                else:
                    return ['((void *)0)']
            return ['((void *)0)']
        elif attr == 'TypeCast':
            # 处理c.TypeCast()调用
            if len(args) >= 2:
                if isinstance(args[0], ast.Constant):
                    type_name = args[0].value
                else:
                    type_name = 'void'
                value = self.HandleExpr(args[1])[0]
                return [f'(({type_name}){value})']
            return ['((void *)0)']
        elif attr == 'Macro':
            # 处理c.Macro()调用
            if len(args) >= 2:
                if isinstance(args[0], ast.Constant):
                    name = args[0].value
                else:
                    name = 'MACRO'
                if isinstance(args[1], ast.Constant):
                    value = args[1].value
                else:
                    value = '0'
                return [f'#define {name} {value}']
            return []
        elif attr == 'Ptr':
            # 处理c.Ptr()调用
            if args:
                addr = self.HandleExpr(args[0])[0]
                value = None
                type_name = None
                # 处理位置参数（第二个参数作为value）
                if len(args) > 1:
                    value = self.HandleExpr(args[1])[0]
                # 处理关键字参数
                for kw in keywords:
                    if kw.arg == 'value':
                        value = self.HandleExpr(kw.value)[0]
                    elif kw.arg == 'type':
                        # 尝试获取类型名称
                        type_name = self.GetTypeName(kw.value)
                if value is not None:
                    if type_name:
                        return [f'*(({type_name}){addr}) = {value};']
                    else:
                        return [f'*((void *){addr}) = {value};']
                else:
                    if type_name:
                        return [f'(({type_name}){addr})']
                    else:
                        return [f'((void *){addr})']
            return ['((void *)0)']
        # 默认处理
        args_str = ', '.join([self.HandleExpr(arg)[0] for arg in args])
        return [f'c.{attr}({args_str});']

    def HandleCAssign(self, line):
        if '=' in line and ';' in line:
            # 简化处理，只提取变量名和值
            line = line.replace(';', '')
            if '=' in line:
                parts = line.split('=')
                var_part = parts[0].strip()
                value_part = '='.join(parts[1:]).strip()
                # 提取变量名（忽略类型和指针）
                var_name = var_part.split()[-1].replace('*', '')
                # 处理多个变量赋值
                if ',' in var_name:
                    vars = var_name.split(',')
                    code = []
                    for var in vars:
                        var = var.strip()
                        code.append(f'{var} = {value_part} // {line}')
                    return code
                else:
                    return [f'{var_name} = {value_part} // {line}']
        return []

    def GeneratePythonCodeFromAST(self, ast, HeaderFiles):
        from pycparser import c_ast
        
        Code = []
        
        class ASTVisitor(c_ast.NodeVisitor):
            def __init__(self, code_list):
                self.code_list = code_list
            
            def visit_Decl(self, node):
                # 处理变量声明
                if isinstance(node.type, c_ast.TypeDecl):
                    var_name = node.name
                    type_name = self.get_type_name(node.type)
                    if node.init:
                        init_code = self.get_expr_code(node.init)
                        self.code_list.append(f'{var_name}: {self.get_python_type(type_name)} = {init_code}')
                    else:
                        self.code_list.append(f'{var_name}: {self.get_python_type(type_name)} = c.State')
            
            def visit_FuncDef(self, node):
                # 处理函数定义
                func_name = node.decl.name
                return_type = self.get_type_name(node.decl.type.type)
                params = []
                if node.decl.type.args:
                    for param in node.decl.type.args.params:
                        param_name = param.name
                        param_type = self.get_type_name(param.type)
                        params.append(f'{param_name}: {self.get_python_type(param_type)}')
                params_str = ', '.join(params)
                return_type_str = self.get_python_type(return_type) if return_type != 'void' else 'None'
                self.code_list.append(f'def {func_name}({params_str}) -> {return_type_str}:')
                self.code_list.append('    pass  # Implementation omitted')
            
            def visit_Struct(self, node):
                # 处理结构体定义
                struct_name = node.name
                self.code_list.append(f'class {struct_name}:')
                self.code_list.append('    pass  # Struct members omitted')
            
            def visit_Enumerator(self, node):
                # 处理枚举值
                enum_name = node.name
                enum_value = node.value.value if node.value else 0
                self.code_list.append(f'{enum_name} = {enum_value}')
            
            def get_type_name(self, type_node):
                # 获取类型名称
                if isinstance(type_node, c_ast.TypeDecl):
                    return self.get_type_name(type_node.type)
                elif isinstance(type_node, c_ast.IdentifierType):
                    return ' '.join(type_node.names)
                elif isinstance(type_node, c_ast.PtrDecl):
                    return f'*{self.get_type_name(type_node.type)}'
                elif isinstance(type_node, c_ast.ArrayDecl):
                    return f'{self.get_type_name(type_node.type)}[]'
                return 'void'
            
            def get_python_type(self, c_type):
                # 将C类型转换为Python类型注解
                type_map = {
                    'int': 't.CInt',
                    'char': 't.CChar',
                    'float': 't.CFloat',
                    'double': 't.CDouble',
                    'void': 't.CVoid',
                    'short': 't.CShort',
                    'long': 't.CLong',
                    'unsigned int': 't.CUnsignedInt',
                    'unsigned char': 't.CUnsignedChar',
                    'unsigned short': 't.CUnsignedShort',
                    'unsigned long': 't.CUnsignedLong',
                    'signed char': 't.CSignedChar',
                    'bool': 't.CBool'
                }
                
                # 处理指针类型
                if c_type.startswith('*'):
                    base_type = c_type[1:]
                    return f't.CPtr | {type_map.get(base_type, base_type)}'
                
                # 处理数组类型
                if c_type.endswith('[]'):
                    base_type = c_type[:-2]
                    return f'c.ClassList[{type_map.get(base_type, base_type)}]'
                
                return type_map.get(c_type, c_type)
            
            def get_expr_code(self, expr_node):
                # 获取表达式代码
                if isinstance(expr_node, c_ast.Constant):
                    return expr_node.value
                elif isinstance(expr_node, c_ast.ID):
                    return expr_node.name
                elif isinstance(expr_node, c_ast.BinaryOp):
                    left = self.get_expr_code(expr_node.left)
                    right = self.get_expr_code(expr_node.right)
                    op = expr_node.op
                    return f'({left} {op} {right})'
                elif isinstance(expr_node, c_ast.UnaryOp):
                    operand = self.get_expr_code(expr_node.expr)
                    op = expr_node.op
                    return f'{op}{operand}'
                return '0'
        
        visitor = ASTVisitor(Code)
        visitor.visit(ast)
        return '\n'.join(Code)

    def Run(self):
        # 检查是否有命令行参数
        if len(sys.argv) > 1:
            # 有命令行参数，使用 ParseArgs 方法解析
            self.ParseArgs()
            input_file = self.Args['Input']
            output_file = self.Args['Output']
        else:
            # 没有命令行参数，使用默认的测试文件名称
            input_file = 'test.py'
            output_file = 'test.c'
            print('Using default test files: test.py -> test.c')
        
        file_type = self.DetectFileType(input_file)

        if file_type == '.py':
            self.PythonToC(input_file, output_file)
        elif file_type == '.c':
            self.CToPython(input_file, output_file, self.HeaderFiles)
        else:
            print(f'Error: Unsupported file type {file_type}')
            sys.exit(1)

        print(f'Successfully converted {input_file} to {output_file}')

if __name__ == '__main__':
    trans = TransPyC()
    trans.Run()